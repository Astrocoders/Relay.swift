(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{114:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return l})),n.d(t,"toc",(function(){return s})),n.d(t,"default",(function(){return u}));var r=n(3),a=n(7),i=(n(0),n(188)),o={title:"Network layer"},l={unversionedId:"api/network",id:"api/network",isDocsHomePage:!1,title:"Network layer",description:"`swift",source:"@site/docs/api/network.md",slug:"/api/network",permalink:"/Relay.swift/docs/next/api/network",editUrl:"https://github.com/relay-tools/Relay.swift/edit/main/website/docs/api/network.md",version:"current",sidebar:"docs",previous:{title:"Environment",permalink:"/Relay.swift/docs/next/api/environment"},next:{title:"Store",permalink:"/Relay.swift/docs/next/api/store"}},s=[{value:"Executing an operation",id:"executing-an-operation",children:[{value:"<code>execute(request:variables:cacheConfig)</code>",id:"executerequestvariablescacheconfig",children:[]}]},{value:"Examples",id:"examples",children:[{value:"Basic URLSession implementation",id:"basic-urlsession-implementation",children:[]},{value:"Authentication with Auth0.swift",id:"authentication-with-auth0swift",children:[]}]}],c={toc:s};function u(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},"protocol Network\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Network")," is a protocol that you implement in your app to control how your Relay.swift talks to your GraphQL API."),Object(i.b)("h2",{id:"executing-an-operation"},"Executing an operation"),Object(i.b)("h3",{id:"executerequestvariablescacheconfig"},Object(i.b)("inlineCode",{parentName:"h3"},"execute(request:variables:cacheConfig)")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},"func execute(\n    request: RequestParameters,\n    variables: VariableData,\n    cacheConfig: CacheConfig\n) -> AnyPublisher<Data, Error>\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Network")," requires you to implement a single method, ",Object(i.b)("inlineCode",{parentName:"p"},"execute"),". Relay.swift will call this method when it needs to make a call to the GraphQL server. You are responsible for making the network call in whatever way makes sense for your app. You return the server's response to Relay.swift through a ",Object(i.b)("inlineCode",{parentName:"p"},"Combine")," publisher."),Object(i.b)("p",null,"This gives you a great deal of flexibility around how your app talks to the server. We'll give a basic example using URLSession and a small Encodable struct, and that will probably be a good starting point for most apps. But you can also substitute another networking library, or even skip calling out to the network at all! The network layer is also a good place to address app-specific concerns like authentication."),Object(i.b)("h4",{id:"parameters"},"Parameters"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"request"),": A ",Object(i.b)("inlineCode",{parentName:"li"},"RequestParameters")," struct with useful properties for generating a GraphQL request body:",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"name: String"),": The operation name from the GraphQL query string. Usually sent in the ",Object(i.b)("inlineCode",{parentName:"li"},"operationName")," field in the request."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"operationKind: OperationKind"),": An enum indicating what type of operation the request is for. Possible values: ",Object(i.b)("inlineCode",{parentName:"li"},".query"),", ",Object(i.b)("inlineCode",{parentName:"li"},".mutation"),", and ",Object(i.b)("inlineCode",{parentName:"li"},".subscription"),", though subscriptions are not yet actually supported."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"text: String?"),": The GraphQL source of the operation, including any necessary fragments. Usually sent in the ",Object(i.b)("inlineCode",{parentName:"li"},"query")," field in the request. Either ",Object(i.b)("inlineCode",{parentName:"li"},"text")," or ",Object(i.b)("inlineCode",{parentName:"li"},"id")," will be set."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"id: String?"),": An identifier for the operation which the server can use to reference a persisted query, rather than having to send the whole query text. Relay.swift does not support persisted queries yet, so this will always be ",Object(i.b)("inlineCode",{parentName:"li"},"nil")," for now."))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"variables"),": The variables for the operation. Usually sent in the ",Object(i.b)("inlineCode",{parentName:"li"},"variables")," field in the request. The ",Object(i.b)("inlineCode",{parentName:"li"},"VariableData")," type conforms to ",Object(i.b)("inlineCode",{parentName:"li"},"Encodable"),", so you can embed this directly in an ",Object(i.b)("inlineCode",{parentName:"li"},"Encodable")," struct to encode them as a JSON object."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"cacheConfig"),": Currently unused, but present here as a placeholder as it's part of the equivalent JavaScript API in Relay.")),Object(i.b)("h4",{id:"returns"},"Returns"),Object(i.b)("p",null,"A Combine publisher that outputs ",Object(i.b)("inlineCode",{parentName:"p"},"Data"),". The data must be a valid JSON-formatted ",Object(i.b)("a",{parentName:"p",href:"https://spec.graphql.org/June2018/#sec-Response"},"GraphQL response"),"."),Object(i.b)("h2",{id:"examples"},"Examples"),Object(i.b)("h3",{id:"basic-urlsession-implementation"},"Basic URLSession implementation"),Object(i.b)("p",null,"This is a great starting point for most apps, and can be customized as needed."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},'import Combine\nimport Foundation\nimport Relay\n\nprivate let graphqlURL = URL(string: "https://www.example.org/graphql")!\n\nstruct RequestPayload: Encodable {\n    var query: String\n    var operationName: String\n    var variables: VariableData\n}\n\nclass Network: Relay.Network {\n    func execute(request: RequestParameters, variables: VariableData, cacheConfig: CacheConfig) -> AnyPublisher<Data, Error> {\n        var req = URLRequest(url: graphqlURL)\n        req.setValue("application/json", forHTTPHeaderField: "Content-Type")\n        req.httpMethod = "POST"\n\n        do {\n            let payload = RequestPayload(query: request.text!, operationName: request.name, variables: variables)\n            req.httpBody = try JSONEncoder().encode(payload)\n        } catch {\n            return Fail(error: error).eraseToAnyPublisher()\n        }\n\n        return URLSession.shared.dataTaskPublisher(for: req)\n            .map { $0.data }\n            .mapError { $0 as Error }\n            .eraseToAnyPublisher()\n    }\n}\n')),Object(i.b)("h3",{id:"authentication-with-auth0swift"},"Authentication with Auth0.swift"),Object(i.b)("p",null,"This example is based on a real app that uses Auth0 for authentication. For each request, it asks the Auth0 credentials manager for the current credentials. If the user's token is expired, the credentials manager may have to request a new one using a refresh token, so getting credentials is an asynchronous call. The network layer wraps this in a Combine ",Object(i.b)("inlineCode",{parentName:"p"},"Future")," and chains this into a data task publisher from URLSession once it has the credentials."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},'import Auth0\nimport Combine\nimport Foundation\nimport Relay\n\nprivate let url = "https://example.org/graphql"\n\nclass Network: Relay.Network {\n    let credentialsManager: CredentialsManager\n\n    init(credentialsManager: CredentialsManager) {\n        self.credentialsManager = credentialsManager\n    }\n\n    func execute(request: RequestParameters, variables: VariableData, cacheConfig: CacheConfig) -> AnyPublisher<Data, Error> {\n        return Future<Credentials, Error> { promise in\n            self.credentialsManager.credentials { error, creds in\n                if let error = error {\n                    promise(.failure(error as Error))\n                } else {\n                    promise(.success(creds!))\n                }\n            }\n        }.flatMap { credentials -> AnyPublisher<Data, Error> in\n            var req = URLRequest(url: self.endpoint.url)\n            req.setValue("application/json", forHTTPHeaderField: "Content-Type")\n            req.httpMethod = "POST"\n            req.setValue("Bearer \\(credentials.accessToken!)", forHTTPHeaderField: "Authorization")\n\n            do {\n                let payload = RequestPayload(query: request.text ?? "", operationName: request.name, variables: variables)\n                req.httpBody = try JSONEncoder().encode(payload)\n            } catch {\n                return Fail(error: error).eraseToAnyPublisher()\n            }\n\n            return URLSession.shared.dataTaskPublisher(for: req)\n                .map { $0.data }\n                .mapError { $0 as Error }\n                .eraseToAnyPublisher()\n        }.eraseToAnyPublisher()\n    }\n}\n\nstruct RequestPayload: Encodable {\n    var query: String\n    var operationName: String\n    var variables: VariableData\n}\n')))}u.isMDXComponent=!0},188:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return h}));var r=n(0),a=n.n(r);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=a.a.createContext({}),u=function(e){var t=a.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=u(e.components);return a.a.createElement(c.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},d=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=u(n),d=r,h=p["".concat(o,".").concat(d)]||p[d]||b[d]||i;return n?a.a.createElement(h,l(l({ref:t},c),{},{components:n})):a.a.createElement(h,l({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);