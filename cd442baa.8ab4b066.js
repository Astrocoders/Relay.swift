(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{159:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return o})),a.d(t,"metadata",(function(){return s})),a.d(t,"toc",(function(){return l})),a.d(t,"default",(function(){return p}));var n=a(3),r=a(7),i=(a(0),a(188)),o={title:"How code generation works"},s={unversionedId:"knowledge-base/code-generation",id:"knowledge-base/code-generation",isDocsHomePage:!1,title:"How code generation works",description:"Relay.swift is designed to provide a type-safe way to interact with your app's data. To do this, we use the Relay compiler from the official JavaScript Relay framework with a custom plugin to generate Swift code instead of JavaScript.",source:"@site/docs/knowledge-base/code-generation.md",slug:"/knowledge-base/code-generation",permalink:"/Relay.swift/docs/next/knowledge-base/code-generation",editUrl:"https://github.com/relay-tools/Relay.swift/edit/main/website/docs/knowledge-base/code-generation.md",version:"current"},l=[{value:"Fragments",id:"fragments",children:[{value:"The fragment type",id:"the-fragment-type",children:[]},{value:"The Data struct",id:"the-data-struct",children:[]},{value:"The Key protocol",id:"the-key-protocol",children:[]}]},{value:"Operations (queries and mutations)",id:"operations-queries-and-mutations",children:[{value:"The operation type",id:"the-operation-type",children:[]},{value:"The Variables struct",id:"the-variables-struct",children:[]},{value:"The Data struct",id:"the-data-struct-1",children:[]},{value:"Unions and Interfaces",id:"unions-and-interfaces",children:[]}]},{value:"Enums",id:"enums",children:[]},{value:"Input types",id:"input-types",children:[]}],c={toc:l};function p(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(n.a)({},c,a,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Relay.swift is designed to provide a type-safe way to interact with your app's data. To do this, we use the Relay compiler from the official JavaScript Relay framework with a custom plugin to generate Swift code instead of JavaScript."),Object(i.b)("p",null,"The types that are generated are based on both your GraphQL schema and any ",Object(i.b)("inlineCode",{parentName:"p"},"graphql()")," strings found in your Swift source files. Each ",Object(i.b)("inlineCode",{parentName:"p"},"query"),", ",Object(i.b)("inlineCode",{parentName:"p"},"mutation"),", and ",Object(i.b)("inlineCode",{parentName:"p"},"fragment")," in your sources will become a generated ",Object(i.b)("inlineCode",{parentName:"p"},".graphql.swift")," file."),Object(i.b)("p",null,"Let's look at examples of what Relay.swift will generate in different situations."),Object(i.b)("h2",{id:"fragments"},"Fragments"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},'private let todoFragment = graphql("""\nfragment ToDoItem_todo on Todo {\n    id\n    text\n    complete\n}\n""")\n')),Object(i.b)("p",null,"We'll use the above GraphQL fragment as our example. When the Relay compiler runs, it will find this fragment and generate a file named ",Object(i.b)("inlineCode",{parentName:"p"},"ToDoItem_todo.graphql.swift"),"."),Object(i.b)("h3",{id:"the-fragment-type"},"The fragment type"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},"struct ToDoItem_todo {\n    var fragmentPointer: FragmentPointer\n\n    init(key: ToDoItem_todo_Key) { /* ... */ }\n\n    static var node: ReaderFragment { /* ... */ }\n}\n")),Object(i.b)("p",null,"First, the compiler will generate a struct with the same name as the fragment. You won't generally have to use its properties and methods yourself; they're there to support Relay itself."),Object(i.b)("p",null,"This is the type that you will pass to ",Object(i.b)("a",{parentName:"p",href:"/Relay.swift/docs/next/api/fragment"},"@Fragment")," in your SwiftUI views."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},"struct ToDoItem: View {\n    @Fragment(ToDoItem_todo.self) var todo\n\n    // ...\n}\n")),Object(i.b)("h3",{id:"the-data-struct"},"The Data struct"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},"extension ToDoItem_todo {\n    struct Data: Decodable {\n        var id: String\n        var text: String\n        var complete: Bool\n    }\n}\n")),Object(i.b)("p",null,"All fragments must have a corresponding ",Object(i.b)("inlineCode",{parentName:"p"},"Data")," type, so the compiler generates a structure that matches the shape of your query. If there are nested fields in the fragment, then it will generate nested types under ",Object(i.b)("inlineCode",{parentName:"p"},"Data")," to represent that data."),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"Data")," type (and any nested types) conforms to Swift's ",Object(i.b)("inlineCode",{parentName:"p"},"Decodable")," protocol. Relay includes a custom ",Object(i.b)("inlineCode",{parentName:"p"},"Decoder")," implementation specifically for reading your types from the Relay store."),Object(i.b)("h3",{id:"the-key-protocol"},"The Key protocol"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},"protocol ToDoItem_todo_Key {\n    var fragment_ToDoItem_todo: FragmentPointer { get }\n}\n")),Object(i.b)("p",null,"Fragments also get a Key protocol, which is conformed to by any generated types where the fragment is spread. The Key protocol requires that the type includes a field to get a pointer to this fragment's data. The Key is used to pass data between different views while only exposing the right data to each one. Fragment pointers don't actually include the fragment's data. Instead, they have just enough information for Relay to be able to load it in the view that needs it."),Object(i.b)("h2",{id:"operations-queries-and-mutations"},"Operations (queries and mutations)"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},'private let query = graphql("""\nquery UserToDoListQuery($id: ID!) {\n    user(id: $id) {\n        id\n        ...ToDoList_user\n    }\n}\n""")\n')),Object(i.b)("p",null,"Again, we'll use an example from the to-do list app. The Relay compiler will generate a file called ",Object(i.b)("inlineCode",{parentName:"p"},"UserToDoListQuery.graphql.swift")," for this query."),Object(i.b)("h3",{id:"the-operation-type"},"The operation type"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},"struct UserToDoListQuery {\n    var variables: Variables\n\n    init(variables: Variables) { /* ... */ }\n\n    static var node: ConcreteRequest { /* ... */ }\n}\n")),Object(i.b)("p",null,"Like fragments, operations get a struct with the same name. Instead of being initialized with a key, operations can have variables to parameterize the operation."),Object(i.b)("h3",{id:"the-variables-struct"},"The Variables struct"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},'extension UserToDoListQuery {\n    struct Variables: VariableDataConvertible {\n        var id: String\n\n        var variableData: VariableData {\n            [\n                "id": id,\n            ]\n        }\n    }\n}\n')),Object(i.b)("p",null,"If the operation takes any variables, a ",Object(i.b)("inlineCode",{parentName:"p"},"Variables")," struct will be generated with the appropriate fields for setting those variables. If it doesn't take any variables, it will instead be a type alias to ",Object(i.b)("inlineCode",{parentName:"p"},"EmptyVariables"),", which enables some shortcuts when using the operation in Relay.swift."),Object(i.b)("p",null,"Variable structs and any ",Object(i.b)("inlineCode",{parentName:"p"},"input")," types contained in them conform to ",Object(i.b)("inlineCode",{parentName:"p"},"VariableDataConvertible"),", another Relay.swift protocol, so there's also a field to convert the variables to ",Object(i.b)("inlineCode",{parentName:"p"},"VariableData"),". ",Object(i.b)("inlineCode",{parentName:"p"},"VariableData")," is a more type-safe wrapper around a dictionary, and it only supports the types that are valid in GraphQL inputs. This allows us to work with the fields of variables internally in Relay while still having them be ",Object(i.b)("inlineCode",{parentName:"p"},"Encodable")," when they need to be sent to the network. "),Object(i.b)("h3",{id:"the-data-struct-1"},"The Data struct"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},"extension UserToDoListQuery {\n    struct Data: Decodable {\n        var user: User_user?\n\n        struct User_user: Decodable, ToDoList_user_Key {\n            var id: String\n            var fragment_ToDoList_user: FragmentPointer\n        }\n    }\n}\n")),Object(i.b)("p",null,"Just like fragments, operations get a ",Object(i.b)("inlineCode",{parentName:"p"},"Data")," struct that is used to read their data from the Relay store. This example shows how nested types are generated when the query includes more than just scalar fields."),Object(i.b)("p",null,"These nested types are generated specifically for the query or fragment reading the data because they need to only include the fields that were requested, not everything that's in the schema. It's even possible to alias fields in a query, giving them a name that isn't even in the schema. The types are generated so that they only include fields that are actually expected to be present."),Object(i.b)("p",null,"Nested data types have a type name based on both the field's type in the GraphQL schema and the field's name in the query. We can't use just the schema type name here because there may be multiple fields with the same schema type, but with different fields selected. So we need a type per field. We could probably name them just based on the field name, but that feels weird."),Object(i.b)("p",null,"In this example, we're spreading the ",Object(i.b)("inlineCode",{parentName:"p"},"ToDoList_user")," fragment onto the ",Object(i.b)("inlineCode",{parentName:"p"},"user")," field. We need to be able to pass this user on to the ",Object(i.b)("inlineCode",{parentName:"p"},"ToDoList")," view, so the ",Object(i.b)("inlineCode",{parentName:"p"},"User_user")," type also conforms to ",Object(i.b)("inlineCode",{parentName:"p"},"ToDoList_user_Key")," and includes a ",Object(i.b)("inlineCode",{parentName:"p"},"fragment_ToDoList_user")," property. This is enough information for the ",Object(i.b)("inlineCode",{parentName:"p"},"ToDoList")," view to load the data it needs from Relay.swift."),Object(i.b)("h3",{id:"unions-and-interfaces"},"Unions and Interfaces"),Object(i.b)("p",null,"TODO"),Object(i.b)("h2",{id:"enums"},"Enums"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-graphql"},"enum PostStatus {\n  DRAFT\n  CANCELED\n  POSTED\n}\n")),Object(i.b)("p",null,"Enums, and input types as we'll see, are a bit special because they may need to be reusable across multiple operations or fragments, so we generate a type for them in the first file where we need them. Thankfully, Swift doesn't really care which file a type is defined in, so from there we can use it wherever we need it."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},'enum PostStatus: String, Decodable, Hashable, VariableValueConvertible, ReadableScalar, CustomStringConvertible {\n    case draft = "DRAFT"\n    case canceled = "CANCELED"\n    case posted = "POSTED"\n\n    var description: String { rawValue }\n}\n')),Object(i.b)("p",null,"GraphQL enums become Swift enums. They always map to strings, and we lowercase them to get a more Swift-y case name."),Object(i.b)("p",null,"Generated enums conform to both ",Object(i.b)("inlineCode",{parentName:"p"},"VariableValueConvertible")," and ",Object(i.b)("inlineCode",{parentName:"p"},"ReadableScalar"),", which makes them usable in both the ",Object(i.b)("inlineCode",{parentName:"p"},"Variables")," and ",Object(i.b)("inlineCode",{parentName:"p"},"Data")," structs mentioned above."),Object(i.b)("h2",{id:"input-types"},"Input types"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-graphql"},"input ChangeTodoStatusInput {\n  complete: Boolean!\n  id: ID!\n  userId: ID!\n  clientMutationId: String\n}\n")),Object(i.b)("p",null,"You might think that we would treat input types similar to nested types inside ",Object(i.b)("inlineCode",{parentName:"p"},"Data")," structs, but we don't actually want or need to. Because we can't use different subsets of fields from an input type in different places in our app, it's much better to have a single version of an input type and reuse it anywhere it's needed."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},'struct ChangeTodoStatusInput: VariableDataConvertible {\n    var complete: Bool\n    var id: String\n    var userId: String\n    var clientMutationId: String?\n\n    var variableData: VariableData {\n        [\n            "complete": complete,\n            "id": id,\n            "userId": userId,\n            "clientMutationId": clientMutationId,\n        ]\n    }\n}\n')),Object(i.b)("p",null,"Input types end up looking a lot like the ",Object(i.b)("inlineCode",{parentName:"p"},"Variables")," structs generated for operations, because besides being unattached to a particular operation, they're the same."))}p.isMDXComponent=!0},188:function(e,t,a){"use strict";a.d(t,"a",(function(){return d})),a.d(t,"b",(function(){return h}));var n=a(0),r=a.n(n);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=r.a.createContext({}),p=function(e){var t=r.a.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},d=function(e){var t=p(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},b=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(a),b=n,h=d["".concat(o,".").concat(b)]||d[b]||u[b]||i;return a?r.a.createElement(h,s(s({ref:t},c),{},{components:a})):r.a.createElement(h,s({ref:t},c))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,o=new Array(i);o[0]=b;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:n,o[1]=s;for(var c=2;c<i;c++)o[c]=a[c];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,a)}b.displayName="MDXCreateElement"}}]);