(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{154:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return m}));var a=n(0),o=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=o.a.createContext({}),p=function(e){var t=o.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return o.a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},b=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,r=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),d=p(n),b=a,m=d["".concat(r,".").concat(b)]||d[b]||u[b]||i;return n?o.a.createElement(m,l(l({ref:t},s),{},{components:n})):o.a.createElement(m,l({ref:t},s))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=b;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var s=2;s<i;s++)r[s]=n[s];return o.a.createElement.apply(null,r)}return o.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"},68:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return l})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return p}));var a=n(3),o=n(7),i=(n(0),n(154)),r={title:"@PaginationFragment"},l={unversionedId:"api/pagination-fragment",id:"api/pagination-fragment",isDocsHomePage:!1,title:"@PaginationFragment",description:"The @PaginationFragment property wrapper is very similar to a @Fragment, but it supports loading additional items upon request. When using a pagination fragment, you don't have to load an entire list of data all at once. You can control when you load more, and you'll be able to easily update your UI accordingly.",source:"@site/docs/api/pagination-fragment.md",slug:"/api/pagination-fragment",permalink:"/Relay.swift/docs/next/api/pagination-fragment",editUrl:"https://github.com/relay-tools/Relay.swift/edit/main/website/docs/api/pagination-fragment.md",version:"current",sidebar:"docs",previous:{title:"@RefetchableFragment",permalink:"/Relay.swift/docs/next/api/refetchable-fragment"},next:{title:"@Mutation",permalink:"/Relay.swift/docs/next/api/mutation"}},c=[{value:"Example",id:"example",children:[]},{value:"Requirements",id:"requirements",children:[]},{value:"Using <code>@connection</code> fields as Collections",id:"using-connection-fields-as-collections",children:[]}],s={toc:c};function p(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"@PaginationFragment")," property wrapper is very similar to a ",Object(i.b)("a",{parentName:"p",href:"/Relay.swift/docs/next/api/fragment"},"@Fragment"),", but it supports loading additional items upon request. When using a pagination fragment, you don't have to load an entire list of data all at once. You can control when you load more, and you'll be able to easily update your UI accordingly."),Object(i.b)("p",null,"A ",Object(i.b)("inlineCode",{parentName:"p"},"@PaginationFragment")," expects your schema to be structured in a specific way to support paging. See the ",Object(i.b)("a",{parentName:"p",href:"https://relay.dev/graphql/connections.htm"},"GraphQL Cursor Connections Specification")," for more details."),Object(i.b)("h2",{id:"example"},"Example"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},'import SwiftUI\nimport RelaySwiftUI\n\nprivate let userFragment = graphql("""\nfragment ToDoList_user on User\n  @refetchable(queryName: "ToDoListPaginationQuery")\n  @argumentDefinitions(\n    count: { type: "Int", defaultValue: 10 }\n    cursor: { type: "Cursor" }\n  ) {\n  todos(first: $count, after: $cursor)\n    @connection(key: "ToDoList_todos") {\n    edges {\n      node {\n        id\n        ...ToDoItem_todo\n      }\n    }\n  }\n}\n""")\n\nstruct ToDoList: View {\n    @PaginationFragment<ToDoList_user> var user\n\n    var body: some View {\n        if let user = user {\n            List {\n                ForEach(user.todos ?? []) { todo in\n                    ToDoItem(todo: todo)\n                }\n\n                if user.isLoadingNext {\n                    Text("Loading\u2026").foregroundColor(.secondary)\n                } else if user.hasNext {\n                    Button("Load more tweets\u2026") {\n                        user.loadNext(10)\n                    }\n                }\n            }\n        }\n    }\n}\n')),Object(i.b)("h2",{id:"requirements"},"Requirements"),Object(i.b)("p",null,"There are a few special requirements for the fragment in order for it to be valid to use with a ",Object(i.b)("inlineCode",{parentName:"p"},"@PaginationFragment"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"The fragment must have a ",Object(i.b)("inlineCode",{parentName:"li"},"@refetchable")," directive that names a query operation that will be generated to fetch additional data for the fragment. Using ",Object(i.b)("inlineCode",{parentName:"li"},"@refetchable")," requires that the fragment be declared on ",Object(i.b)("inlineCode",{parentName:"li"},"Query"),", ",Object(i.b)("inlineCode",{parentName:"li"},"Viewer"),", or a type that implements the ",Object(i.b)("inlineCode",{parentName:"li"},"Node"),". Otherwise, Relay won't know where in the graph to fetch the new data from."),Object(i.b)("li",{parentName:"ul"},"A field in the fragment must have a ",Object(i.b)("inlineCode",{parentName:"li"},"@connection")," directive that marks the connection field to use for paging. See the ",Object(i.b)("a",{parentName:"li",href:"https://relay.dev/graphql/connections.htm"},"GraphQL Cursor Connections Specification")," for more about connections.")),Object(i.b)("h4",{id:"parameters"},"Parameters"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"F"),": A type parameter (surrounded in ",Object(i.b)("inlineCode",{parentName:"li"},"<>"),") for the type of the fragment to use. The type will be generated by the Relay compiler with a name matching the fragment name in the GraphQL snippet.")),Object(i.b)("h4",{id:"property-value"},"Property value"),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"@PaginationFragment")," property will be a read-only optional value with the fields the fragment requests. This value will automatically update and re-render the view when more items are loaded or when the Relay store updates any relevant records."),Object(i.b)("p",null,"The value will also include some additional properties related to paging and refetching:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"isLoadingNext: Bool"),": Indicates if there is an in-flight request to load more items from the end of the list."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"isLoadingPrevious: Bool"),": Indicates if there is an in-flight request to load more items from the beginning of the list."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"hasNext: Bool"),": Indicates if there are more items that can be fetched from the end of the list."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"hasPrevious: Bool"),": Indicates if there are more items that can be fetched from the beginning of the list."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"loadNext(_ count: Int)"),": Function that can be called to fetch the next ",Object(i.b)("inlineCode",{parentName:"li"},"count")," items from the end of the list."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"loadPrevious(_ count: Int)"),": Function that can be called to fetch the previous ",Object(i.b)("inlineCode",{parentName:"li"},"count")," items from the beginning of the list."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"refetch(_ variables: Variables? = nil)"),": Function that can be called to trigger a refetch of the fragment's data. ",Object(i.b)("inlineCode",{parentName:"li"},"variables")," will be the variables for the refetch query that Relay generates for you. This may change which node the fragment is targetting from then on. That's okay: Relay will keep track of that for you, but be aware that it may not match the original fragment your view is passing in.")),Object(i.b)("h2",{id:"using-connection-fields-as-collections"},"Using ",Object(i.b)("inlineCode",{parentName:"h2"},"@connection")," fields as Collections"),Object(i.b)("p",null,"When generating the data types for a pagination fragment, the Relay compiler can make it easier to use your connection by making it usable as a Swift Collection. For example, here are the types generated for the above example ",Object(i.b)("inlineCode",{parentName:"p"},"ToDoList_user")," fragment:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},"extension ToDoList_user {\n    public struct Data: Decodable {\n        public var todos: TodoConnection_todos?\n        public var id: String?\n\n        public struct TodoConnection_todos: Decodable, ConnectionCollection {\n            public var edges: [TodoEdge_edges?]?\n\n            public struct TodoEdge_edges: Decodable, ConnectionEdge {\n                public var node: Todo_node?\n\n                public struct Todo_node: Decodable, Identifiable, ToDoItem_todo_Key, ConnectionNode {\n                    public var id: String\n                    public var fragment_ToDoItem_todo: FragmentPointer\n                }\n            }\n        }\n    }\n}\n")),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"todos")," field is the ",Object(i.b)("inlineCode",{parentName:"p"},"@connection")," field, and has type ",Object(i.b)("inlineCode",{parentName:"p"},"TodoConnection_todos"),". The ",Object(i.b)("inlineCode",{parentName:"p"},"TodoConnection_todos")," conforms to ",Object(i.b)("inlineCode",{parentName:"p"},"ConnectionCollection"),", which makes it usable as a Collection. In general, you can use the ",Object(i.b)("inlineCode",{parentName:"p"},"todos")," field as though it were an array, including in a SwiftUI ",Object(i.b)("inlineCode",{parentName:"p"},"List")," or ",Object(i.b)("inlineCode",{parentName:"p"},"ForEach"),"."),Object(i.b)("p",null,"This conformance is only generated when your fragment includes the following structure:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-graphql"},"fragment MyFragment_foo {\n    someItems @connection(key: ...) {\n        edges {\n            node {\n                ...\n            }\n        }\n    }\n}\n")),Object(i.b)("p",null,"In other words, your fragment must have a field with the ",Object(i.b)("inlineCode",{parentName:"p"},"@connection")," directive. That field must have an ",Object(i.b)("inlineCode",{parentName:"p"},"edges")," field selected, and the ",Object(i.b)("inlineCode",{parentName:"p"},"edges")," field must have a ",Object(i.b)("inlineCode",{parentName:"p"},"node")," field selected. If those conditions are met, the Relay compiler will make the types for those fields conform to the necessary protocols to be able to use the connection field as a Collection."),Object(i.b)("p",null,"In practice, this means that referring to your paged items in your view is much nicer. Instead of this:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},"List(user.todos?.edges?.compactMap { $0?.node } ?? []) { ... }\n")),Object(i.b)("p",null,"You can just write:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},"List(user.todos ?? []) { ... }\n")),Object(i.b)("p",null,"This gives you the benefits of using GraphQL cursors for paging, but without burdening your view code with worrying about edges and their nodes."))}p.isMDXComponent=!0}}]);